# A class to add together anything.
class VectorNumber
  # ---- Generic types ----
  type real_number = Integer | Float | Rational | BigDecimal

  type in_value_type = untyped
  type unit_type = untyped
  type coefficient_type = real_number

  type list[T] = Array[T]

  type plain_instance = Hash[unit_type, coefficient_type]
  type units_list_type = list[unit_type]
  type coefficients_list_type = list[coefficient_type]
  type each_value_type = [unit_type, coefficient_type]

  # ---- Constants ----

  VERSION: String

  NUMERIC_UNITS: list[SpecialUnit]
  R: SpecialUnit
  I: SpecialUnit

  # ---- Public methods ----

  def self.[]: (*unit_type values) -> instance

  def self.numeric_unit?: (unit_type unit) -> bool

  def size: -> Integer

  def initialize:
    (?(units_list_type | plain_instance | instance)? values)
    ?{ (coefficient_type coefficient) -> coefficient_type }
    -> void

  def +@: () -> self
  alias dup +@

  def clone: (?freeze: bool?) -> self

  private

  @size: Integer
  @data: plain_instance

  def new: () { (coefficient_type value) -> coefficient_type } -> instance
         | (in_value_type) { (coefficient_type value) -> coefficient_type } -> instance
         | () -> instance
         | (in_value_type) -> instance

  def real_number?: (real_number value) -> true
                  | (instance) -> bool
                  | (in_value_type value) -> false

  def initialize_from: ((units_list_type | plain_instance | instance)? values) -> void

  def add_value_to_data: ((instance | Numeric | unit_type) value) -> void

  def add_numeric_value_to_data: (Numeric value) -> void

  def add_vector_to_data: ((instance | plain_instance) vector) -> void

  def apply_transform: () ?{ (coefficient_type value) -> coefficient_type } -> void

  def finalize_contents: () -> void
end

# Methods for performing actual math.
class VectorNumber
  def coerce: (in_value_type) -> [instance, self]

  def -@: () -> instance
  alias neg -@

  def +: (in_value_type) -> instance
  alias add +

  def -: (in_value_type) -> instance
  alias sub -

  def *: (real_number | instance) -> instance
  alias mult *

  def /: (real_number | instance) -> instance
  alias quo /

  def fdiv: (real_number | instance) -> instance

  def div: (real_number | instance) -> instance

  def ceildiv: (real_number | instance) -> instance

  def %: (real_number | instance) -> instance
  alias modulo %

  def divmod: (real_number | instance) -> [instance, instance]

  def remainder: (real_number | instance) -> instance

  private

  def check_divisibility: (real_number | instance) -> void
end

# Various mathematical operations that are also conversions.
class VectorNumber
  def truncate: (?Integer) -> instance

  def ceil: (?Integer) -> instance

  def floor: (?Integer) -> instance

  def round: (?Integer, ?half: (:up | :down | :even)) -> instance
end

# Methods for converting to different number classes.
class VectorNumber
  def real: () -> real_number

  def imaginary: () -> real_number
  alias imag imaginary

  def to_i: () -> Integer
  alias to_int to_i

  def to_f: () -> Float

  def to_r: () -> Rational

  def to_d: (?Integer?) -> BigDecimal

  def to_c: () -> Complex

  private

  def raise_convert_error: (Class) -> void
end

class VectorNumber
  include _Each[each_value_type]
  include Enumerable[each_value_type]

  def each: () { (unit_type unit, coefficient_type coefficient) -> void } -> self
          | () -> Enumerator[each_value_type, Integer]
          | ...
  alias each_pair each

  def units: () -> units_list_type
  alias keys units

  def coefficients: () -> coefficients_list_type
  alias values coefficients

  def to_h: () -> plain_instance
          | () { (unit_type, coefficient_type) -> each_value_type } -> plain_instance

  def []: (unit_type unit) -> coefficient_type

  def unit?: (unit_type unit) -> bool
  alias key? unit?
end

# Methods for comparing with other numbers.
class VectorNumber
  def ==: (in_value_type other) -> bool

  def eql?: (in_value_type other) -> bool

  def hash: () -> Integer

  def <=>: (in_value_type other) -> Integer?
end

# Methods for querying state of the number.
# Mostly modeled after {::Complex}.
class VectorNumber
  def numeric?: (?Integer) -> bool

  def nonnumeric?: (?Integer) -> bool

  def finite?: () -> bool

  def infinite?: () -> Integer?

  def zero?: () -> bool

  def nonzero?: () -> self?

  def positive?: () -> bool

  def negative?: () -> bool

  def real?: () -> false

  def integer?: () -> false
end

# Methods and options for string representation.
class VectorNumber
  MULT_STRINGS: Hash[Symbol, String]

  def to_s: (?mult: (Symbol | String)) { (unit_type, coefficient_type, ?Integer index, ?String operator) -> String } -> String

  def inspect: () -> String

  private

  def build_string: (String operator) -> String
                  | (String operator) { (unit_type, coefficient_type, ?Integer index, ?String operator) -> String } -> String

  def value_to_s: (unit_type unit, coefficient_type coefficient, String operator) -> String
end

# Vector operations.
class VectorNumber
  def abs: () -> Float
  alias magnitude abs
  alias euclidean_norm abs

  def abs2: () -> Float

  def p_norm: (Numeric power) -> Numeric

  def maximum_norm: () -> Numeric

  def subspace_basis: () -> Array[instance]

  def uniform_vector: () -> instance

  def unit_vector: () -> instance

  def dot_product: (in_value_type other) -> coefficient_type
  alias inner_product dot_product
  alias scalar_product dot_product

  def angle: (in_value_type other) -> Float

  def scalar_projection: (in_value_type other) -> coefficient_type

  def vector_projection: (in_value_type other) -> instance

  def scalar_rejection: (in_value_type other) -> coefficient_type

  def vector_rejection: (in_value_type other) -> instance

  private

  def has_direction?: (?in_value_type vector) -> void
end

class VectorNumber
  # Refinements of Numeric classes to better work with VectorNumber and similar classes.
  module NumericRefinements
    module CommutativeShuttle
      def <=>: (in_value_type other) -> Integer?
    end

    module BigDecimalToD
      def BigDecimal: (untyped value, exception: bool) -> BigDecimal?
                    | (untyped value, Integer ndigits, exception: bool) -> BigDecimal?
    end
  end
end

class VectorNumber
  # Class for representing special numerical units.
  class SpecialUnit
    def initialize: (Object unit, String text) -> void

    def to_s: () -> String
    
    def inspect: () -> String
  end
end
